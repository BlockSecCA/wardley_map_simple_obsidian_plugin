/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => WardleyMapPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/parser.ts
function parseWardleyMap(source) {
  const lines = source.split("\n");
  const errors = [];
  const map = {
    components: [],
    dependencies: [],
    evolutions: [],
    annotations: [],
    notes: []
  };
  const componentMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    const lineNum = i + 1;
    if (!line || line.startsWith("#"))
      continue;
    try {
      if (line.startsWith("title ")) {
        map.title = line.substring(6).trim();
        continue;
      }
      const componentMatch = line.match(
        /^component\s+(.+?)\s+\[(\w+)\]$/
      );
      if (componentMatch) {
        const name = componentMatch[1].trim();
        const stage = componentMatch[2];
        if (!isValidStage(stage)) {
          errors.push({
            line: lineNum,
            message: `Invalid evolution stage '${stage}'. Must be: genesis, custom, product, commodity`
          });
          continue;
        }
        if (componentMap.has(name)) {
          errors.push({
            line: lineNum,
            message: `Component '${name}' declared multiple times`
          });
          continue;
        }
        const component = { name, stage, isAnchor: false };
        componentMap.set(name, component);
        map.components.push(component);
        continue;
      }
      const anchorMatch = line.match(/^anchor\s+(.+?)\s+\[(\w+)\]$/);
      if (anchorMatch) {
        const name = anchorMatch[1].trim();
        const stage = anchorMatch[2];
        if (!isValidStage(stage)) {
          errors.push({
            line: lineNum,
            message: `Invalid evolution stage '${stage}'. Must be: genesis, custom, product, commodity`
          });
          continue;
        }
        if (componentMap.has(name)) {
          errors.push({
            line: lineNum,
            message: `Component '${name}' declared multiple times`
          });
          continue;
        }
        const component = { name, stage, isAnchor: true };
        componentMap.set(name, component);
        map.components.push(component);
        continue;
      }
      const evolveMatch = line.match(
        /^evolve\s+(.+?)\s+->\s+(.+?)\s+\[(\w+)\]$/
      );
      if (evolveMatch) {
        const from = evolveMatch[1].trim();
        const to = evolveMatch[2].trim();
        const stage = evolveMatch[3];
        if (!componentMap.has(from)) {
          errors.push({
            line: lineNum,
            message: `Component '${from}' not declared`
          });
          continue;
        }
        if (!componentMap.has(to)) {
          errors.push({
            line: lineNum,
            message: `Component '${to}' not declared`
          });
          continue;
        }
        map.evolutions.push({ from, to, stage });
        continue;
      }
      const evolveStageMatch = line.match(
        /^evolve\s+(.+?)\s+\[(\w+)\]$/
      );
      if (evolveStageMatch) {
        const name = evolveStageMatch[1].trim();
        const stage = evolveStageMatch[2];
        if (!componentMap.has(name)) {
          errors.push({
            line: lineNum,
            message: `Component '${name}' not declared`
          });
          continue;
        }
        continue;
      }
      if (line.includes("->")) {
        parseDependencyChain(
          line,
          lineNum,
          componentMap,
          map.dependencies,
          errors
        );
        continue;
      }
      const annotationMatch = line.match(/^annotation\s+(\S+)\s+(.+)$/);
      if (annotationMatch) {
        const id = annotationMatch[1];
        const text = annotationMatch[2];
        map.annotations.push({ id, text });
        continue;
      }
      if (line.startsWith("note ")) {
        map.notes.push(line.substring(5).trim());
        continue;
      }
      if (line) {
        errors.push({
          line: lineNum,
          message: `Unknown syntax: ${line}`
        });
      }
    } catch (e) {
      errors.push({
        line: lineNum,
        message: `Error parsing line: ${e}`
      });
    }
  }
  for (const dep of map.dependencies) {
    if (!componentMap.has(dep.from)) {
      errors.push({
        line: 0,
        message: `Component '${dep.from}' referenced but not declared`
      });
    }
    if (!componentMap.has(dep.to)) {
      errors.push({
        line: 0,
        message: `Component '${dep.to}' referenced but not declared`
      });
    }
  }
  return {
    map: errors.length === 0 ? map : null,
    errors
  };
}
function parseDependencyChain(line, lineNum, componentMap, dependencies, errors) {
  const parts = line.split("->");
  for (let i = 0; i < parts.length - 1; i++) {
    let from = parts[i].trim();
    let to = parts[i + 1].trim();
    let label;
    const semicolonIdx = to.indexOf(";");
    if (semicolonIdx !== -1) {
      label = to.substring(semicolonIdx + 1).trim();
      to = to.substring(0, semicolonIdx).trim();
    }
    if (i === 0) {
      const fromSemicolonIdx = from.indexOf(";");
      if (fromSemicolonIdx !== -1) {
        from = from.substring(0, fromSemicolonIdx).trim();
      }
    }
    dependencies.push({ from, to, label });
  }
}
function isValidStage(stage) {
  return ["genesis", "custom", "product", "commodity"].includes(stage);
}

// src/renderer.ts
var STAGE_POSITIONS = {
  genesis: 0.125,
  // 12.5% (centered in 0-25%)
  custom: 0.375,
  // 37.5% (centered in 25-50%)
  product: 0.625,
  // 62.5% (centered in 50-75%)
  commodity: 0.875
  // 87.5% (centered in 75-100%)
};
var STAGE_LABELS = {
  genesis: "Genesis",
  custom: "Custom Built",
  product: "Product",
  commodity: "Commodity"
};
var STAGE_COLORS = {
  genesis: { fill: "#FF6B6B", stroke: "#C92A2A" },
  // Red - novel, uncertain
  custom: { fill: "#4ECDC4", stroke: "#0B7285" },
  // Teal - custom built
  product: { fill: "#45B7D1", stroke: "#1971C2" },
  // Blue - product
  commodity: { fill: "#96CEB4", stroke: "#2F9E44" }
  // Green - commodity
};
function renderWardleyMap(map, options = {}) {
  var _a, _b, _c, _d, _e;
  const width = (_a = options.width) != null ? _a : 800;
  const height = (_b = options.height) != null ? _b : 600;
  const padding = (_c = options.padding) != null ? _c : 60;
  const nodeRadius = (_d = options.nodeRadius) != null ? _d : 8;
  const fontSize = (_e = options.fontSize) != null ? _e : 12;
  calculatePositions(map);
  const svg = [];
  svg.push(
    `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" class="wardley-map">`
  );
  svg.push(`<defs>
		<marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
			<polygon points="0 0, 10 3, 0 6" fill="#4A90E2" />
		</marker>
		<marker id="arrowhead-evolution" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
			<polygon points="0 0, 10 3, 0 6" fill="#9B59B6" />
		</marker>
	</defs>`);
  svg.push(`<rect width="${width}" height="${height}" fill="white"/>`);
  const stageY = height - padding + 30;
  const stages = ["genesis", "custom", "product", "commodity"];
  for (const stage of stages) {
    const x = padding + STAGE_POSITIONS[stage] * (width - 2 * padding);
    svg.push(
      `<line x1="${x}" y1="${padding}" x2="${x}" y2="${height - padding}" stroke="#e0e0e0" stroke-width="1" stroke-dasharray="4,4"/>`
    );
    svg.push(
      `<text x="${x}" y="${stageY}" text-anchor="middle" font-size="11" fill="#666">${STAGE_LABELS[stage]}</text>`
    );
  }
  svg.push(
    `<text x="${width / 2}" y="${height - 10}" text-anchor="middle" font-size="12" font-weight="bold" fill="#333">Evolution \u2192</text>`
  );
  svg.push(
    `<text x="20" y="${height / 2}" text-anchor="middle" font-size="12" font-weight="bold" fill="#333" transform="rotate(-90, 20, ${height / 2})">Value Chain \u2191</text>`
  );
  if (map.title) {
    svg.push(
      `<text x="${width / 2}" y="30" text-anchor="middle" font-size="18" font-weight="bold" fill="#000">${escapeHtml(map.title)}</text>`
    );
  }
  for (const dep of map.dependencies) {
    const fromComp = map.components.find((c) => c.name === dep.from);
    const toComp = map.components.find((c) => c.name === dep.to);
    if (fromComp && toComp && fromComp.x !== void 0 && fromComp.y !== void 0 && toComp.x !== void 0 && toComp.y !== void 0) {
      const x1 = padding + fromComp.x * (width - 2 * padding);
      const y1 = padding + fromComp.y * (height - 2 * padding - 40);
      const x2 = padding + toComp.x * (width - 2 * padding);
      const y2 = padding + toComp.y * (height - 2 * padding - 40);
      svg.push(
        `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#4A90E2" stroke-width="2" marker-end="url(#arrowhead)"/>`
      );
      if (dep.label) {
        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        svg.push(
          `<text x="${midX}" y="${midY - 5}" text-anchor="middle" font-size="10" fill="#666">${escapeHtml(dep.label)}</text>`
        );
      }
    }
  }
  for (const evo of map.evolutions) {
    const fromComp = map.components.find((c) => c.name === evo.from);
    const toComp = map.components.find((c) => c.name === evo.to);
    if (fromComp && toComp && fromComp.x !== void 0 && fromComp.y !== void 0 && toComp.x !== void 0 && toComp.y !== void 0) {
      const x1 = padding + fromComp.x * (width - 2 * padding);
      const y1 = padding + fromComp.y * (height - 2 * padding - 40);
      const x2 = padding + toComp.x * (width - 2 * padding);
      const y2 = padding + toComp.y * (height - 2 * padding - 40);
      svg.push(
        `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#9B59B6" stroke-width="2" stroke-dasharray="5,5" marker-end="url(#arrowhead-evolution)"/>`
      );
    }
  }
  for (const comp of map.components) {
    if (comp.x === void 0 || comp.y === void 0) {
      console.warn(`Skipping component ${comp.name} - x: ${comp.x}, y: ${comp.y}`);
      continue;
    }
    const x = padding + comp.x * (width - 2 * padding);
    const y = padding + comp.y * (height - 2 * padding - 40);
    const colors = getStageColors(comp.stage);
    const fillColor = colors.fill;
    const strokeColor = colors.stroke;
    svg.push(
      `<circle cx="${x}" cy="${y}" r="${nodeRadius}" fill="${fillColor}" stroke="${strokeColor}" stroke-width="2" class="${comp.isAnchor ? "anchor" : "component"}"/>`
    );
    svg.push(
      `<text x="${x}" y="${y - nodeRadius - 5}" text-anchor="middle" font-size="${fontSize}" font-weight="bold" fill="#000">${escapeHtml(comp.name)}</text>`
    );
  }
  if (map.annotations.length > 0) {
    let annotY = height - 35;
    for (const ann of map.annotations) {
      svg.push(
        `<text x="${padding}" y="${annotY}" font-size="10" fill="#666">[${ann.id}] ${escapeHtml(ann.text)}</text>`
      );
      annotY += 12;
    }
  }
  svg.push("</svg>");
  return svg.join("\n");
}
function getStageColors(stage) {
  return STAGE_COLORS[stage];
}
function calculatePositions(map) {
  var _a;
  for (const comp of map.components) {
    comp.x = STAGE_POSITIONS[comp.stage];
  }
  const layers = topologicalSort(map.components, map.dependencies);
  const maxLayer = Math.max(...layers.values(), 0);
  for (const comp of map.components) {
    const layer = (_a = layers.get(comp.name)) != null ? _a : 0;
    comp.y = (maxLayer - layer) / (maxLayer + 1);
    if (comp.isAnchor) {
      comp.y = 0;
    }
  }
  for (const evo of map.evolutions) {
    const sourceComp = map.components.find((c) => c.name === evo.from);
    const targetComp = map.components.find((c) => c.name === evo.to);
    if (sourceComp && targetComp && sourceComp.y !== void 0) {
      targetComp.y = sourceComp.y;
    }
  }
  spreadOverlappingComponents(map.components);
  for (const comp of map.components) {
    console.log(`Component: ${comp.name}, x: ${comp.x}, y: ${comp.y}, stage: ${comp.stage}, isAnchor: ${comp.isAnchor}`);
  }
}
function spreadOverlappingComponents(components) {
  var _a;
  const groups = /* @__PURE__ */ new Map();
  for (const comp of components) {
    const key = `${(_a = comp.y) == null ? void 0 : _a.toFixed(3)}_${comp.stage}`;
    if (!groups.has(key)) {
      groups.set(key, []);
    }
    groups.get(key).push(comp);
  }
  for (const [key, group] of groups) {
    if (group.length > 1) {
      const baseX = group[0].x;
      const baseSpread = 0.12;
      const spreadMultiplier = Math.max(1, group.length / 3);
      const spreadRange = baseSpread * spreadMultiplier;
      group.forEach((comp, index) => {
        const offset = (index - (group.length - 1) / 2) * (spreadRange / Math.max(group.length - 1, 1));
        comp.x = baseX + offset;
      });
    }
  }
}
function topologicalSort(components, dependencies) {
  var _a, _b, _c, _d, _e, _f;
  const layers = /* @__PURE__ */ new Map();
  const inDegree = /* @__PURE__ */ new Map();
  const graph = /* @__PURE__ */ new Map();
  for (const comp of components) {
    inDegree.set(comp.name, 0);
    graph.set(comp.name, []);
  }
  for (const dep of dependencies) {
    (_a = graph.get(dep.to)) == null ? void 0 : _a.push(dep.from);
    inDegree.set(dep.from, ((_b = inDegree.get(dep.from)) != null ? _b : 0) + 1);
  }
  const queue = [];
  for (const comp of components) {
    if (inDegree.get(comp.name) === 0) {
      queue.push(comp.name);
      layers.set(comp.name, 0);
    }
  }
  while (queue.length > 0) {
    const current = queue.shift();
    const currentLayer = (_c = layers.get(current)) != null ? _c : 0;
    for (const neighbor of (_d = graph.get(current)) != null ? _d : []) {
      const newDegree = ((_e = inDegree.get(neighbor)) != null ? _e : 0) - 1;
      inDegree.set(neighbor, newDegree);
      const neighborLayer = (_f = layers.get(neighbor)) != null ? _f : 0;
      layers.set(neighbor, Math.max(neighborLayer, currentLayer + 1));
      if (newDegree === 0) {
        queue.push(neighbor);
      }
    }
  }
  return layers;
}
function escapeHtml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

// src/main.ts
var WardleyMapPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Wardley Map Simple plugin");
    this.registerMarkdownCodeBlockProcessor(
      "wardley",
      (source, el, ctx) => {
        this.renderWardleyBlock(source, el);
      }
    );
  }
  onunload() {
    console.log("Unloading Wardley Map Simple plugin");
  }
  /**
   * Render a Wardley map code block
   */
  renderWardleyBlock(source, container) {
    container.empty();
    const { map, errors } = parseWardleyMap(source);
    if (errors.length > 0) {
      const errorDiv = container.createDiv({
        cls: "wardley-map-error"
      });
      errorDiv.createEl("h4", {
        text: "Wardley Map Parse Errors:"
      });
      const errorList = errorDiv.createEl("ul");
      for (const error of errors) {
        const li = errorList.createEl("li");
        li.setText(
          error.line > 0 ? `Line ${error.line}: ${error.message}` : error.message
        );
      }
      return;
    }
    if (map) {
      const mapDiv = container.createDiv({
        cls: "wardley-map-container"
      });
      const svg = renderWardleyMap(map, {
        width: 800,
        height: 600,
        padding: 60,
        nodeRadius: 8,
        fontSize: 12
      });
      mapDiv.innerHTML = svg;
    }
  }
};
